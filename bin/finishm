#!/usr/bin/env ruby

require 'optparse'
require 'bio-logger'
require 'bio-velvet'
require 'pp'

SCRIPT_NAME = File.basename(__FILE__); LOG_NAME = 'finishm'
$:.unshift File.join(File.dirname(__FILE__),'..','lib')
require 'priner'

# Parse command line options into the options hash
options = {
  :logger => 'stderr',
  :log_level => 'info',
}
global = OptionParser.new do |opts|
  opts.banner = "
    Usage: #{SCRIPT_NAME} <command> [<arguments>]

    FinishM is a collection of related tasks:

    finish\tprocess results from multi-primer multi-lane PCR experimental setup
    gapfill\tFill assembly gaps (N characters)
    \n\n"
end
global.order!

operator = nil
subcommands = {
  'finish' => OptionParser.new do |opts|
     # ...
  end,
  'gapfill' => OptionParser.new do |opts|
    require 'finishm/gapfiller'
    operator = Bio::FinishM::GapFiller.new
    operator.add_options(opts, options)
  end
}

# Setup logging
Bio::Log::CLI.logger(options[:logger]); Bio::Log::CLI.trace(options[:log_level]); log = Bio::Log::LoggerPlus.new(LOG_NAME); Bio::Log::CLI.configure(LOG_NAME)
Bio::Log::LoggerPlus.new 'bio-velvet'; Bio::Log::CLI.configure 'bio-velvet'

subcommand = ARGV.shift
subcommands[subcommand].parse!
if operator.nil?
  log.error "No subcommand detected."
  $stderr.puts global.usage
  exit 1
else
  operator.run ARGV
end
